package moretype

import "fmt"

//struct
type Vertex struct {
	X int
	Y int
}

//templateによる実装の隠蔽など
//については今後追記
//構造体の中に構造体を埋め込む
//Class like struct



//初期化の説明のため記載
//varとして並べて表記できる
var(
	v1 = Vertex{1,2}//X=1,Y=2設定
	v3 = Vertex{}	//自動初期化(0/0)
	v2 = Vertex{X: 1}//Xのみ指定して初期化(X: 1)
	p = &Vertex{1,2} //structへのポインタを格納
	//ポインタを使う方が良いかどうかは調査中
)

func Globalvprint(){
	fmt.Println(v1,v3,v2,p)
}

func Mkstruct(){
	v := Vertex{1,2}
	//Access
	v.X = 4
	fmt.Println(v)
}

func Strpointer(){
	//structのポインタ経由のアクセス
	//本来は(*p).Xが正しいが略記として以下が使える
	//これはメソッド定義に良く用いる
	v := Vertex{1,2}
	p := &v
	p.X = 1e9
	fmt.Println(v)
}

func Pointer() {
	i := 42
	p := &i
	*p = *p * 3
	fmt.Println(*p)
	fmt.Println(i)
}

func Printarray(){
	//この配列は値渡しになる
	//そのため関数で操作させる場合はポインタを渡す
	//また配列長は型の一部のため不変
	//利便性なども含めスライスに軍配が挙がる
	primes := [3]int{2,3,4}
	primes[2] = 23232
	fmt.Println(primes)
}

func Printsliceabnormal(){
	primes := [6]int{2,3,4,5,6,7}
	//要素の0から4を切り出したスライス
	//後ろの数字は0からでなく1から始まる数値で数える
	//つまり0:0で長さ0のスライスを生成
	//またこれは元配列のポインタみたいなものなので
	//何らかの変更を行うと共有するスライスは全て影響を受ける
	//これにより関数に渡す時はそのまま渡せる
	//さらに型の指定が簡単になるので便利
	//より高度な型指定はinterfaceで行う
	//0値のスライス(nilスライス)
	s := primes[0:0]
	//4以降を切り出したもの
	v := primes[2:]
	//2より手前
	g := primes[:3]
	//全て
	all := primes[:]
	//これを足すと全ての4が90になる
	//all[2] = 90
	fmt.Println(s,v,g,all)
}

func Printslicepat1(){
	//初期化を伴うsliceの作り方
	//この場合は自動で適切な配列を作成してくれる
	q := []int{2,3,4}
	r := []bool{true,false}
	//構造体もこんな感じに
	s := []struct{
		i int
		b bool
	}{
		{2,true},
		{3,false},
		{4,true},
	}
	//削り落とすこともできる
	//また[:]とすることで再びアクセスできるようになる(再スライス)
	//ただし頭を切り落とすと([1:]など)その箇所は参照不可能になる
	//詳細はmakeによるsliceで
	s = s[:2]

	fmt.Println(q,r,s)
}

func Printslicenormal(){
	//sliceは長さlenと容量capを持つ
	//lenはそのsliceが持つ要素数
	//capはその配列が持ちうる量(元となる配列の要素数)
	//なので5個のintが入るのを使いたければ次をsliceに入れるとできる
	//[5]int
	//より便利な宣言方法はmakeを用いる
	//len,capを指定(capは任意)
	s := make([]int, 3, 5)
	//再スライス
	s = s[:cap(s)]
	fmt.Println("len=%d, cap=%v\n",len(s),cap(s),s)
	//絶対的な容量が必要ならスライス後のを別のスライスとして保存するか
	//頭を切らないか、配列を作ってからスライスするかを取る
}
